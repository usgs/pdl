<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HashFileProductStorage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pdl</a> &gt; <a href="index.source.html" class="el_package">gov.usgs.earthquake.distribution</a> &gt; <span class="el_source">HashFileProductStorage.java</span></div><h1>HashFileProductStorage.java</h1><pre class="source lang-java linenums">package gov.usgs.earthquake.distribution;

import gov.usgs.earthquake.product.ProductId;

import java.io.File;
import java.security.MessageDigest;
import java.util.logging.Logger;

/**
 * A FileProductStorage that builds directory paths based on a SHA-1 hash of the
 * product id.
 *
 * This helps overcome a limitation of the ext3 filesystem which limits the
 * number of subdirectories any one directory may contain to 32000. This
 * implementation should generate no more than 4096 (16 ^ 3) subdirectories of
 * any one subdirectory.
 *
 * Note: no collision handling has been implemented, although hash collisions
 * are not expected.
 *
 * Examples: &lt;br&gt;
 * Product ID: urn:usgs-product:us:shakemap:abcd1234:1304116272636 &lt;br&gt;
 * SHA-1 hash: dde7b3986ee2fda8a793b599b6ae725ab35df58b &lt;br&gt;
 * Directory: shakemap/dde/7b3/986/ee2/fda/8a7/93b/599/b6a/e72/5ab/35d/f58/b &lt;br&gt;
 * &lt;br&gt;
 * Product ID: urn:usgs-product:us:shakemap2:efgh5678:1304116272711 &lt;br&gt;
 * SHA-1 hash: 8174d0f8d961d48c8a94a6bd0ab2a882e01173c6 &lt;br&gt;
 * Directory: shakemap2/817/4d0/f8d/961/d48/c8a/94a/6bd/0ab/2a8/82e/011/73c/6
 *
 * @deprecated
 * @see FileProductStorage
 */
public class HashFileProductStorage extends FileProductStorage {

<span class="nc" id="L35">	private static Logger LOGGER = Logger</span>
<span class="nc" id="L36">			.getLogger(HashFileProductStorage.class.getName());</span>

	// create this digest once, and clone it later
	private static final MessageDigest SHA_DIGEST;
	static {
<span class="nc" id="L41">		MessageDigest digest = null;</span>
		try {
<span class="nc" id="L43">			digest = MessageDigest.getInstance(&quot;SHA&quot;);</span>
<span class="nc" id="L44">		} catch (Exception e) {</span>
<span class="nc" id="L45">			LOGGER.warning(&quot;Unable to create SHA Digest for HashFileProductStorage&quot;);</span>
<span class="nc" id="L46">			digest = null;</span>
<span class="nc" id="L47">		}</span>
<span class="nc" id="L48">		SHA_DIGEST = digest;</span>
<span class="nc" id="L49">	}</span>

	/**
	 * This is chosen because 16^3 = 4096 &amp;lt; 32000, which is the ext3
	 * subdirectory limit.
	 */
	public static final int DIRECTORY_NAME_LENGTH = 3;

	public HashFileProductStorage() {
<span class="nc" id="L58">		super();</span>
<span class="nc" id="L59">	}</span>

	public HashFileProductStorage(final File directory) {
<span class="nc" id="L62">		super(directory);</span>
<span class="nc" id="L63">	}</span>

	/**
	 * A method for subclasses to override the storage path.
	 *
	 * The returned path is appended to the base directory when storing and
	 * retrieving products.
	 *
	 * @param id
	 *            the product id to convert.
	 * @return the directory used to store id.
	 */
	@Override
	public String getProductPath(final ProductId id) {
		try {
			MessageDigest digest;
<span class="nc" id="L79">			synchronized (SHA_DIGEST) {</span>
<span class="nc" id="L80">				digest = ((MessageDigest) SHA_DIGEST.clone());</span>
<span class="nc" id="L81">			}</span>

<span class="nc" id="L83">			String hexDigest = toHexString(digest.digest(id.toString()</span>
<span class="nc" id="L84">					.getBytes()));</span>

<span class="nc" id="L86">			StringBuffer buf = new StringBuffer();</span>
			// start with product type, to give idea of available products and
			// disk usage when looking at filesystem
<span class="nc" id="L89">			buf.append(id.getType());</span>

			// sub directories based on hash
<span class="nc" id="L92">			int length = hexDigest.length();</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">			for (int i = 0; i &lt; length; i += DIRECTORY_NAME_LENGTH) {</span>
				String part;
<span class="nc bnc" id="L95" title="All 2 branches missed.">				if (i + DIRECTORY_NAME_LENGTH &lt; length) {</span>
<span class="nc" id="L96">					part = hexDigest.substring(i, i + DIRECTORY_NAME_LENGTH);</span>
				} else {
<span class="nc" id="L98">					part = hexDigest.substring(i);</span>
				}
<span class="nc" id="L100">				buf.append(File.separator);</span>
<span class="nc" id="L101">				buf.append(part);</span>
			}

<span class="nc" id="L104">			return buf.toString();</span>
<span class="nc" id="L105">		} catch (CloneNotSupportedException e) {</span>
			// fall back to parent class
<span class="nc" id="L107">			return super.getProductPath(id);</span>
		}
	}

	/**
	 * Convert an array of bytes into a hex string. The string will always be
	 * twice as long as the input byte array, because bytes &lt; 0x10 are zero
	 * padded.
	 *
	 * @param bytes
	 *            byte array to convert to hex.
	 * @return hex string equivalent of input byte array.
	 */
	private String toHexString(final byte[] bytes) {
<span class="nc" id="L121">		StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L122">		int length = bytes.length;</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">		for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L124">			String hex = Integer.toHexString(0xFF &amp; bytes[i]);</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">			if (hex.length() == 1) {</span>
<span class="nc" id="L126">				buf.append('0');</span>
			}
<span class="nc" id="L128">			buf.append(hex);</span>
		}
<span class="nc" id="L130">		return buf.toString();</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>